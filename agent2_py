from agt_server.agents.base_agents.adx_agent import NDaysNCampaignsAgent
from agt_server.agents.test_agents.adx.tier1.my_agent import Tier1NDaysNCampaignsAgent
from agt_server.local_games.adx_arena import AdXGameSimulator
from agt_server.agents.utils.adx.structures import Bid, Campaign, BidBundle, MarketSegment 
from typing import Set, Dict, Optional


# optimizing for profit over 10 days : sum _ campaings (p(C) B_c - K_c)
# B_c is budget won in campaing
# K_c is money spent in ad auctions for users that match C
# p(C) is effective reach [0, 1.384] given by sigmoid over x/R
# Quality score also impacts chance of getting free campaigns with min(1, Q)
# Real knob: cpm_c \geq B/R (campaign unprofitable)

class TrialNDaysNCampaignsAgent(NDaysNCampaignsAgent):

    def __init__(self):
        # TODO: fill this in (if necessary)
        super().__init__()
        self.name = "Trial Agent"
        self.total_impressions = 0.0
        self.total_cost = 0.0
        self.estimated_cpm = 0.2 # cost per impression
        self.all_segments = list(MarketSegment.all_segments())

    def on_new_game(self) -> None:
        # TODO: fill this in (if necessary)
        self.total_impressions = 0.0
        self.total_cost = 0.0
        self.estimated_cpm = 0.2

    def logging_info(self): 
        current_day = self.get_current_day()
        print(f"DAY {current_day} REPORT for {self.name}")
        print("-"*60)
        print(f"Quality Score: {self.get_quality_score():.4f}")
        print(f"Estimated CPM: {self.estimated_cpm:.4f}")
        print(f"Active Campaigns: {len(self.get_active_campaigns())}\n")

        for camp in self.get_active_campaigns():
            x = self.get_cumulative_reach(camp)
            k = self.get_cumulative_cost(camp)
            days_left = max(camp.end_day - current_day + 1, 1)

            print(f"Campaign {camp.uid}:")
            print(f"  Segment:         {camp.target_segment}")
            print(f"  Reach R:         {camp.reach}")
            print(f"  Budget B:        {camp.budget}")
            print(f"  x so far:        {x}")
            print(f"  Cost so far:     {k:.2f}")
            print(f"  Days left:       {days_left}")
            print("-"*40)

        print("="*60 + "\n")



    def get_ad_bids(self) -> Set[BidBundle]:
        bundles: Set[BidBundle] = set()
        current_day = self.get_current_day()
        active_campaigns = self.get_active_campaigns()

        # --- Update global CPM estimate from *all* active campaigns ---
        total_impressions = 0.0
        total_cost = 0.0
        for campaign in active_campaigns:
            x = self.get_cumulative_reach(campaign)
            k = self.get_cumulative_cost(campaign)
            total_impressions += x
            total_cost += k

        if total_impressions > 0:
            self.total_impressions = total_impressions
            self.total_cost = total_cost
            self.estimated_cpm = total_cost / total_impressions

        for campaign in active_campaigns:
            R = campaign.reach
            B = campaign.budget
            reach_so_far = self.get_cumulative_reach(campaign)
            cost_so_far = self.get_cumulative_cost(campaign)

            # Remaining reach & days
            remaining_impressions = max(R - reach_so_far, 0)
            if remaining_impressions <= 0:
                continue  # already satisfied (or overshot); stop bidding

            days_left = max(campaign.end_day - current_day + 1, 1)

            # Value per impression from this campaign
            vpi = (B / R) if R > 0 else 0.0

            # Basic bid per impression: some fraction of value, with no urgency yet
            base_bid = 0.7 * vpi

            # Add an urgency factor: if lots of reach remains & end is near, bid a bit more
            frac_remaining = remaining_impressions / R
            urgency = 1.0 + 0.5 * frac_remaining
            if days_left == 1:
                urgency *= 1.2

            bid_per_item = base_bid * urgency
            # Never bid more than value per impression
            bid_per_item = min(bid_per_item, vpi)

            # Remaining budget for this campaign
            remaining_budget = max(B - cost_so_far, 0.0)
            if remaining_budget <= 0:
                continue  # we already spent its whole budget

            # Daily campaign-level spending limit:
            # spend at most some fraction of remaining budget spread over remaining days
            daily_fraction = 0.7  # tune: 0.5–0.8
            campaign_daily_limit = daily_fraction * remaining_budget / days_left
            if campaign_daily_limit <= 0:
                continue

            # Find compatible segments: user segment must SUPerset campaign target
            compatible_segments = [
                seg for seg in self.all_segments
                if campaign.target_segment.issubset(seg)
            ]
            if not compatible_segments:
                continue

            per_segment_limit = campaign_daily_limit / len(compatible_segments)

            bid_entries: Set[Bid] = set()
            for segment in compatible_segments:
                bid = Bid(
                    bidder=self,
                    auction_item=segment,
                    bid_per_item=bid_per_item,
                    bid_limit=per_segment_limit,
                )
                bid_entries.add(bid)

            bundle = BidBundle(
                campaign_id=campaign.uid,         # or campaignId depending on your API
                limit=campaign_daily_limit,
                bid_entries=bid_entries,
            )
            bundles.add(bundle)

        print("ad bids for day", current_day)
        self.logging_info()
        return bundles

    # Choosing bids for reverse second-price auction in [0.1R, R]
    # Lower bid is more likely to win, but less revenue
    # need to estimate cost per impression for campaign

    def get_campaign_bids(self,
                          campaigns_for_auction: Set[Campaign]) -> Dict[Campaign, float]:
        bids: Dict[Campaign, float] = {}

        current_day = self.get_current_day()
        Q = self.get_quality_score()

        # How much we still care about boosting Q (early vs late in 10-day game)
        q_weight = max(0.0, (10 - current_day) / 9.0)

        # Base desired profit margin when we take a campaign
        base_margin = 0.25  # 25% margin over expected cost

        # If Q is high and it's early, we can accept slightly smaller margins
        q_adjust = 0.1 * q_weight * (Q - 1.0)
        profit_margin = max(0.10, base_margin - q_adjust)

        estimated_cpm = max(self.estimated_cpm, 0.05)  # floor to avoid craziness

        for campaign in campaigns_for_auction:
            R = campaign.reach
            if R <= 0:
                continue

            # Expected cost to fully satisfy at current CPM estimate
            expected_cost_full = R * estimated_cpm

            # Minimum budget we are willing to accept to get this campaign:
            min_budget = expected_cost_full * (1.0 + profit_margin)

            # If even the *maximum* allowed bid (R) is below this,
            # the campaign cannot be profitable within allowed range → skip.
            if min_budget > R:
                continue

            # Otherwise, bid at that min_budget (clipped into [0.1R, R])
            bid = self.clip_campaign_bid(campaign, min_budget)

            if self.is_valid_campaign_bid(campaign, bid):
                bids[campaign] = bid

        return bids

if __name__ == "__main__":
    # Here's an opportunity to test offline against some TA agents. Just run this file to do so.
    test_agents = [TrialNDaysNCampaignsAgent()] + [Tier1NDaysNCampaignsAgent(name=f"Agent {i + 1}") for i in range(9)]

    # Don't change this. Adapt initialization to your environment
    simulator = AdXGameSimulator()
    simulator.run_simulation(agents=test_agents, num_simulations=1)